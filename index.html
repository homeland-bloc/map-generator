import React, { useState, useRef, useEffect } from 'react';
import { Download, Wand2, Trash2 } from 'lucide-react';

const CANVAS_WIDTH = 21;
const CANVAS_HEIGHT = 33;
const TILE_SIZE = 16;

// Terrain types and their gameplay properties:
// WALL (üß±): Blocks movement AND shooting - solid cover
// WATER (üåä): Blocks movement but NOT shooting - can shoot through
// GRASS (ü•¨): Blocks neither - players can hide/walk/shoot through
// EMPTY: Open space - no restrictions

const TERRAIN_TYPES = {
  WALL: '#A0522D',
  WATER: '#5DADE2',
  GRASS: '#2ECC71',
  EMPTY: null
};

const MapGenerator = () => {
  const [tiles, setTiles] = useState(() => 
    Array(CANVAS_HEIGHT).fill(null).map(() => Array(CANVAS_WIDTH).fill(null))
  );
  const [selectedTool, setSelectedTool] = useState(TERRAIN_TYPES.WALL);
  const [isDrawing, setIsDrawing] = useState(false);
  const [toolbarOpen, setToolbarOpen] = useState(true);
  const [wallDensity, setWallDensity] = useState(15);
  const [waterDensity, setWaterDensity] = useState(10);
  const [grassDensity, setGrassDensity] = useState(15);
  const [mirrorVertical, setMirrorVertical] = useState(false);
  const [mirrorHorizontal, setMirrorHorizontal] = useState(false);
  const [mirrorDiagonal, setMirrorDiagonal] = useState(false);
  const canvasRef = useRef(null);

  const handleTileClick = (row, col) => {
    const newTiles = [...tiles.map(r => [...r])];
    newTiles[row][col] = selectedTool;
    
    const centerRow = Math.floor(CANVAS_HEIGHT / 2);
    const centerCol = Math.floor(CANVAS_WIDTH / 2);
    
    if (mirrorVertical) {
      const mirrorCol = CANVAS_WIDTH - 1 - col;
      newTiles[row][mirrorCol] = selectedTool;
    }
    if (mirrorHorizontal) {
      const mirrorRow = CANVAS_HEIGHT - 1 - row;
      newTiles[mirrorRow][col] = selectedTool;
    }
    if (mirrorDiagonal) {
      const offsetRow = row - centerRow;
      const offsetCol = col - centerCol;
      const mirrorRow = centerRow - offsetRow;
      const mirrorCol = centerCol - offsetCol;
      if (mirrorRow >= 0 && mirrorRow < CANVAS_HEIGHT && mirrorCol >= 0 && mirrorCol < CANVAS_WIDTH) {
        newTiles[mirrorRow][mirrorCol] = selectedTool;
      }
    }
    if (mirrorVertical && mirrorHorizontal) {
      const mirrorRow = CANVAS_HEIGHT - 1 - row;
      const mirrorCol = CANVAS_WIDTH - 1 - col;
      newTiles[mirrorRow][mirrorCol] = selectedTool;
    }
    
    setTiles(newTiles);
  };

  const handleMouseDown = (row, col) => {
    setIsDrawing(true);
    handleTileClick(row, col);
  };

  const handleMouseEnter = (row, col) => {
    if (isDrawing) {
      handleTileClick(row, col);
    }
  };

  const handleMouseUp = () => {
    setIsDrawing(false);
  };

  useEffect(() => {
    document.addEventListener('mouseup', handleMouseUp);
    return () => document.removeEventListener('mouseup', handleMouseUp);
  }, []);

  const generateRandomMap = () => {
    console.log('=== STARTING MAP GENERATION ===');
    const newTiles = Array(CANVAS_HEIGHT).fill(null).map(() => Array(CANVAS_WIDTH).fill(null));

    // ===== HELPER FUNCTIONS =====
    const isValid = (row, col) => row >= 0 && row < CANVAS_HEIGHT && col >= 0 && col < CANVAS_WIDTH;

    const getNeighbors4 = (row, col) => {
      return [
        [row-1, col], [row+1, col], [row, col-1], [row, col+1]
      ].filter(([r, c]) => isValid(r, c));
    };

    const getNeighbors8 = (row, col) => {
      return [
        [row-1, col], [row+1, col], [row, col-1], [row, col+1],
        [row-1, col-1], [row-1, col+1], [row+1, col-1], [row+1, col+1]
      ].filter(([r, c]) => isValid(r, c));
    };

    const floodFill = (startRow, startCol, targetType) => {
      const queue = [[startRow, startCol]];
      const visited = new Set();
      const cluster = [];

      while (queue.length > 0) {
        const [row, col] = queue.shift();
        const key = `${row},${col}`;

        if (!isValid(row, col) || visited.has(key) || newTiles[row][col] !== targetType) continue;

        visited.add(key);
        cluster.push([row, col]);

        getNeighbors4(row, col).forEach(([r, c]) => {
          if (!visited.has(`${r},${c}`)) queue.push([r, c]);
        });
      }

      return cluster;
    };

    const applyMirrors = (row, col, type) => {
      const mirrored = [[row, col]];

      if (mirrorVertical) {
        const mirrorCol = CANVAS_WIDTH - 1 - col;
        if (isValid(row, mirrorCol)) mirrored.push([row, mirrorCol]);
      }
      if (mirrorHorizontal) {
        const mirrorRow = CANVAS_HEIGHT - 1 - row;
        if (isValid(mirrorRow, col)) mirrored.push([mirrorRow, col]);
      }
      if (mirrorDiagonal) {
        const centerRow = Math.floor(CANVAS_HEIGHT / 2);
        const centerCol = Math.floor(CANVAS_WIDTH / 2);
        const offsetRow = row - centerRow;
        const offsetCol = col - centerCol;
        const mirrorRow = centerRow - offsetRow;
        const mirrorCol = centerCol - offsetCol;
        if (isValid(mirrorRow, mirrorCol)) mirrored.push([mirrorRow, mirrorCol]);
      }
      if (mirrorVertical && mirrorHorizontal) {
        const mirrorRow = CANVAS_HEIGHT - 1 - row;
        const mirrorCol = CANVAS_WIDTH - 1 - col;
        if (isValid(mirrorRow, mirrorCol)) mirrored.push([mirrorRow, mirrorCol]);
      }

      mirrored.forEach(([r, c]) => {
        if (isValid(r, c)) newTiles[r][c] = type;
      });
    };

    const centerRow = Math.floor(CANVAS_HEIGHT / 2);
    const centerCol = Math.floor(CANVAS_WIDTH / 2);
    const totalTiles = CANVAS_WIDTH * CANVAS_HEIGHT;

    // ===== PHASE 1: INITIAL BLOB GENERATION (IMPROVED) =====
    console.log('\n--- PHASE 1: Initial Blob Generation ---');

    const terrainConfigs = [];
    if (wallDensity > 0) terrainConfigs.push({
      type: TERRAIN_TYPES.WALL,
      density: wallDensity,
      spreadChance: 0.35 + Math.random() * 0.10,
      name: 'WALL'
    });
    if (waterDensity > 0) terrainConfigs.push({
      type: TERRAIN_TYPES.WATER,
      density: waterDensity,
      spreadChance: 0.50 + Math.random() * 0.10,
      name: 'WATER'
    });
    if (grassDensity > 0) terrainConfigs.push({
      type: TERRAIN_TYPES.GRASS,
      density: grassDensity,
      spreadChance: 0.60 + Math.random() * 0.10,
      name: 'GRASS'
    });

    terrainConfigs.forEach(({ type, density, spreadChance, name }) => {
      const targetCount = Math.floor((density / 100) * totalTiles);
      const blobCount = Math.floor(5 + Math.random() * 10); // 5-15 blobs
      let placedCount = 0;

      console.log(`  ${name}: target=${targetCount}, blobs=${blobCount}, spread=${spreadChance.toFixed(2)}`);

      for (let i = 0; i < blobCount && placedCount < targetCount; i++) {
        let startRow = Math.floor(Math.random() * CANVAS_HEIGHT);
        let startCol = Math.floor(Math.random() * CANVAS_WIDTH);

        // Adjust starting position for mirror modes
        if (mirrorVertical && !mirrorHorizontal && !mirrorDiagonal) {
          startCol = Math.floor(Math.random() * (CANVAS_WIDTH / 2));
        }
        if (mirrorHorizontal && !mirrorVertical && !mirrorDiagonal) {
          startRow = Math.floor(Math.random() * (CANVAS_HEIGHT / 2));
        }
        if (mirrorVertical && mirrorHorizontal) {
          startRow = Math.floor(Math.random() * (CANVAS_HEIGHT / 2));
          startCol = Math.floor(Math.random() * (CANVAS_WIDTH / 2));
        }

        if (newTiles[startRow][startCol] !== null) continue;

        const queue = [[startRow, startCol]];
        const visited = new Set();

        // Variable blob size: 3-30 tiles
        const minBlobSize = 3;
        const maxBlobSize = 30;
        const blobSize = Math.min(
          Math.floor(minBlobSize + Math.random() * (maxBlobSize - minBlobSize)),
          targetCount - placedCount
        );
        let currentBlobSize = 0;

        while (queue.length > 0 && currentBlobSize < blobSize && placedCount < targetCount) {
          const [row, col] = queue.shift();
          const key = `${row},${col}`;

          if (!isValid(row, col) || visited.has(key) || newTiles[row][col] !== null) continue;

          visited.add(key);
          const mirrorMultiplier = applyMirrors(row, col, type).length;
          placedCount += mirrorMultiplier;
          currentBlobSize++;

          const neighbors = getNeighbors4(row, col);
          neighbors.forEach(([r, c]) => {
            if (Math.random() < spreadChance && newTiles[r][c] === null && !visited.has(`${r},${c}`)) {
              queue.push([r, c]);
            }
          });
        }
      }
      console.log(`  ${name}: placed=${placedCount}`);
    });

    // ===== PHASE 2: PROTRUSION REMOVAL (NEW) =====
    console.log('\n--- PHASE 2: Protrusion Removal ---');
    let protrusionsRemoved = 0;

    for (let pass = 0; pass < 4; pass++) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          if (newTiles[row][col] !== null) {
            const type = newTiles[row][col];
            const neighbors = getNeighbors4(row, col);
            const sameTypeNeighbors = neighbors.filter(([r, c]) => newTiles[r][c] === type);

            // If tile has only 1-2 neighbors of same type, it's a potential protrusion
            if (sameTypeNeighbors.length <= 2) {
              // Check if it's part of a 2+ tile wide structure
              let isPartOfWideStructure = false;

              for (const [nr, nc] of sameTypeNeighbors) {
                const neighborNeighbors = getNeighbors4(nr, nc);
                const neighborSameType = neighborNeighbors.filter(([r, c]) =>
                  newTiles[r][c] === type && (r !== row || c !== col)
                );

                if (neighborSameType.length >= 2) {
                  isPartOfWideStructure = true;
                  break;
                }
              }

              if (!isPartOfWideStructure) {
                newTiles[row][col] = null;
                protrusionsRemoved++;
              }
            }
          }
        }
      }
    }
    console.log(`  Protrusions removed: ${protrusionsRemoved}`);

    // ===== PHASE 3: COMPREHENSIVE GAP FILLING (ENHANCED) =====
    console.log('\n--- PHASE 3: Comprehensive Gap Filling ---');
    let gapsFilled = 0;

    for (let pass = 0; pass < 6; pass++) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          if (newTiles[row][col] === null) {
            const neighbors4 = getNeighbors4(row, col);
            const neighbors8 = getNeighbors8(row, col);
            const filledNeighbors4 = neighbors4.filter(([r, c]) => newTiles[r][c] !== null);
            const filledNeighbors8 = neighbors8.filter(([r, c]) => newTiles[r][c] !== null);

            // Rule 1: If 3+ orthogonal neighbors are filled
            if (filledNeighbors4.length >= 3) {
              const terrainCounts = {};
              filledNeighbors4.forEach(([r, c]) => {
                const terrain = newTiles[r][c];
                terrainCounts[terrain] = (terrainCounts[terrain] || 0) + 1;
              });

              let mostCommon = null;
              let maxCount = 0;
              Object.entries(terrainCounts).forEach(([terrain, count]) => {
                if (count > maxCount) {
                  maxCount = count;
                  mostCommon = terrain;
                }
              });

              newTiles[row][col] = mostCommon;
              gapsFilled++;
              continue;
            }

            // Rule 2: Vertical corridor
            const top = row > 0 ? newTiles[row - 1][col] : null;
            const bottom = row < CANVAS_HEIGHT - 1 ? newTiles[row + 1][col] : null;
            if (top !== null && bottom !== null) {
              newTiles[row][col] = top;
              gapsFilled++;
              continue;
            }

            // Rule 3: Horizontal corridor
            const left = col > 0 ? newTiles[row][col - 1] : null;
            const right = col < CANVAS_WIDTH - 1 ? newTiles[row][col + 1] : null;
            if (left !== null && right !== null) {
              newTiles[row][col] = left;
              gapsFilled++;
              continue;
            }

            // Rule 4: If 5+ of 8 neighbors (including diagonals) are filled
            if (filledNeighbors8.length >= 5) {
              const terrainCounts = {};
              filledNeighbors8.forEach(([r, c]) => {
                const terrain = newTiles[r][c];
                terrainCounts[terrain] = (terrainCounts[terrain] || 0) + 1;
              });

              let mostCommon = null;
              let maxCount = 0;
              Object.entries(terrainCounts).forEach(([terrain, count]) => {
                if (count > maxCount) {
                  maxCount = count;
                  mostCommon = terrain;
                }
              });

              newTiles[row][col] = mostCommon;
              gapsFilled++;
            }
          }
        }
      }
    }
    console.log(`  Gaps filled: ${gapsFilled}`);

    // ===== PHASE 4: MINIMUM FEATURE SIZE ENFORCEMENT (NEW) =====
    console.log('\n--- PHASE 4: Minimum Feature Size Enforcement ---');
    let clustersRemoved = 0;
    const processed = new Set();

    for (let pass = 0; pass < 3; pass++) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          const key = `${row},${col}`;
          if (newTiles[row][col] !== null && !processed.has(key)) {
            const type = newTiles[row][col];
            const cluster = floodFill(row, col, type);

            cluster.forEach(([r, c]) => processed.add(`${r},${c}`));

            if (cluster.length < 4) {
              cluster.forEach(([r, c]) => {
                newTiles[r][c] = null;
              });
              clustersRemoved++;
            }
          }
        }
      }
    }
    console.log(`  Small clusters removed: ${clustersRemoved}`);

    // ===== PHASE 5: TERRAIN-SPECIFIC CLEANUP =====
    console.log('\n--- PHASE 5: Terrain-Specific Cleanup ---');

    // Water thinning
    for (let pass = 0; pass < 2; pass++) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          if (newTiles[row][col] === TERRAIN_TYPES.WATER) {
            const neighbors = getNeighbors4(row, col);
            const waterNeighbors = neighbors.filter(([r, c]) => newTiles[r][c] === TERRAIN_TYPES.WATER);

            if (waterNeighbors.length <= 1) {
              newTiles[row][col] = null;
            }
          }
        }
      }
    }

    // Isolated grass removal
    for (let row = 0; row < CANVAS_HEIGHT; row++) {
      for (let col = 0; col < CANVAS_WIDTH; col++) {
        if (newTiles[row][col] === TERRAIN_TYPES.GRASS) {
          const neighbors = getNeighbors4(row, col);
          const grassNeighbors = neighbors.filter(([r, c]) => newTiles[r][c] === TERRAIN_TYPES.GRASS);

          if (grassNeighbors.length === 0) {
            newTiles[row][col] = null;
          }
        }
      }
    }
    console.log('  Terrain-specific cleanup complete');

    // ===== PHASE 6: CONNECTIVITY VERIFICATION (NEW) =====
    console.log('\n--- PHASE 6: Connectivity Verification ---');

    // Find all empty regions
    const emptyRegions = [];
    const emptyProcessed = new Set();

    for (let row = 0; row < CANVAS_HEIGHT; row++) {
      for (let col = 0; col < CANVAS_WIDTH; col++) {
        const key = `${row},${col}`;
        if (newTiles[row][col] === null && !emptyProcessed.has(key)) {
          const region = floodFill(row, col, null);
          region.forEach(([r, c]) => emptyProcessed.add(`${r},${c}`));
          emptyRegions.push(region);
        }
      }
    }

    if (emptyRegions.length > 1) {
      console.log(`  Found ${emptyRegions.length} disconnected regions, connecting...`);
      // Keep the largest region, remove barriers to others
      emptyRegions.sort((a, b) => b.length - a.length);
      const mainRegion = new Set(emptyRegions[0].map(([r, c]) => `${r},${c}`));

      // Simple approach: remove some terrain tiles between regions
      for (let i = 1; i < emptyRegions.length; i++) {
        const region = emptyRegions[i];
        // Find a tile in this region closest to main region
        for (const [row, col] of region) {
          const neighbors = getNeighbors4(row, col);
          for (const [nr, nc] of neighbors) {
            if (newTiles[nr][nc] !== null) {
              newTiles[nr][nc] = null; // Remove barrier
              break;
            }
          }
        }
      }
    } else {
      console.log('  All empty spaces are connected');
    }

    // ===== PHASE 7: SMOOTHING PASS (NEW) =====
    console.log('\n--- PHASE 7: Smoothing Pass ---');
    let smoothingChanges = 0;

    for (let row = 1; row < CANVAS_HEIGHT - 1; row++) {
      for (let col = 1; col < CANVAS_WIDTH - 1; col++) {
        if (newTiles[row][col] !== null) {
          const type = newTiles[row][col];

          // Check for jaggy diagonal-only connections
          const top = newTiles[row - 1][col];
          const bottom = newTiles[row + 1][col];
          const left = newTiles[row][col - 1];
          const right = newTiles[row][col + 1];

          const orthogonalSame = [top, bottom, left, right].filter(t => t === type).length;

          // If no orthogonal neighbors of same type, but has diagonal neighbors, it's jaggy
          if (orthogonalSame === 0) {
            const diagonals = [
              newTiles[row - 1][col - 1],
              newTiles[row - 1][col + 1],
              newTiles[row + 1][col - 1],
              newTiles[row + 1][col + 1]
            ];
            const diagonalSame = diagonals.filter(t => t === type).length;

            if (diagonalSame > 0) {
              newTiles[row][col] = null;
              smoothingChanges++;
            }
          }
        }
      }
    }
    console.log(`  Smoothing changes: ${smoothingChanges}`);

    // ===== PHASE 8: EDGE CLEANUP =====
    console.log('\n--- PHASE 8: Edge Cleanup ---');
    const edgeMargin = 1;
    let edgeCleanups = 0;

    for (let row = 0; row < CANVAS_HEIGHT; row++) {
      for (let col = 0; col < CANVAS_WIDTH; col++) {
        const isNearEdge = row < edgeMargin || row >= CANVAS_HEIGHT - edgeMargin ||
                          col < edgeMargin || col >= CANVAS_WIDTH - edgeMargin;

        if (isNearEdge && newTiles[row][col] !== null) {
          const neighbors = getNeighbors4(row, col);
          const sameTypeNeighbors = neighbors.filter(([r, c]) => newTiles[r][c] === newTiles[row][col]);

          // Remove if not part of 3+ tile structure
          if (sameTypeNeighbors.length < 2) {
            newTiles[row][col] = null;
            edgeCleanups++;
          }
        }
      }
    }
    console.log(`  Edge cleanups: ${edgeCleanups}`);

    // ===== PHASE 9: MIRROR SYNCHRONIZATION =====
    console.log('\n--- PHASE 9: Mirror Synchronization ---');

    if (mirrorDiagonal) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          const offsetRow = row - centerRow;
          const offsetCol = col - centerCol;
          const mirrorRow = centerRow - offsetRow;
          const mirrorCol = centerCol - offsetCol;

          if (isValid(mirrorRow, mirrorCol)) {
            if (newTiles[row][col] !== null && newTiles[mirrorRow][mirrorCol] === null) {
              newTiles[mirrorRow][mirrorCol] = newTiles[row][col];
            } else if (newTiles[row][col] === null && newTiles[mirrorRow][mirrorCol] !== null) {
              newTiles[row][col] = newTiles[mirrorRow][mirrorCol];
            }
          }
        }
      }
      console.log('  Diagonal mirror synchronized');
    }

    if (mirrorVertical) {
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < Math.ceil(CANVAS_WIDTH / 2); col++) {
          const mirrorCol = CANVAS_WIDTH - 1 - col;
          if (newTiles[row][col] !== newTiles[row][mirrorCol]) {
            newTiles[row][mirrorCol] = newTiles[row][col];
          }
        }
      }
      console.log('  Vertical mirror synchronized');
    }

    if (mirrorHorizontal) {
      for (let row = 0; row < Math.ceil(CANVAS_HEIGHT / 2); row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          const mirrorRow = CANVAS_HEIGHT - 1 - row;
          if (newTiles[row][col] !== newTiles[mirrorRow][col]) {
            newTiles[mirrorRow][col] = newTiles[row][col];
          }
        }
      }
      console.log('  Horizontal mirror synchronized');
    }

    // ===== PHASE 10: FINAL VALIDATION (NEW) =====
    console.log('\n--- PHASE 10: Final Validation ---');

    // Final comprehensive passes to catch any remaining issues
    for (let pass = 0; pass < 2; pass++) {
      let fixedInPass = 0;

      // Check for one-tile gaps
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          if (newTiles[row][col] === null) {
            const neighbors4 = getNeighbors4(row, col);
            const filledNeighbors = neighbors4.filter(([r, c]) => newTiles[r][c] !== null);

            if (filledNeighbors.length >= 3) {
              const terrainCounts = {};
              filledNeighbors.forEach(([r, c]) => {
                const terrain = newTiles[r][c];
                terrainCounts[terrain] = (terrainCounts[terrain] || 0) + 1;
              });

              let mostCommon = null;
              let maxCount = 0;
              Object.entries(terrainCounts).forEach(([terrain, count]) => {
                if (count > maxCount) {
                  maxCount = count;
                  mostCommon = terrain;
                }
              });

              newTiles[row][col] = mostCommon;
              fixedInPass++;
            }
          }
        }
      }

      // Check for one-tile protrusions
      for (let row = 0; row < CANVAS_HEIGHT; row++) {
        for (let col = 0; col < CANVAS_WIDTH; col++) {
          if (newTiles[row][col] !== null) {
            const type = newTiles[row][col];
            const neighbors = getNeighbors4(row, col);
            const sameTypeNeighbors = neighbors.filter(([r, c]) => newTiles[r][c] === type);

            if (sameTypeNeighbors.length === 0) {
              newTiles[row][col] = null;
              fixedInPass++;
            }
          }
        }
      }

      if (fixedInPass > 0) {
        console.log(`  Final validation pass ${pass + 1}: fixed ${fixedInPass} issues`);
      }
    }

    // ===== FINAL STATISTICS =====
    console.log('\n=== GENERATION COMPLETE ===');
    let wallCount = 0, waterCount = 0, grassCount = 0, emptyCount = 0;

    for (let row = 0; row < CANVAS_HEIGHT; row++) {
      for (let col = 0; col < CANVAS_WIDTH; col++) {
        const tile = newTiles[row][col];
        if (tile === TERRAIN_TYPES.WALL) wallCount++;
        else if (tile === TERRAIN_TYPES.WATER) waterCount++;
        else if (tile === TERRAIN_TYPES.GRASS) grassCount++;
        else emptyCount++;
      }
    }

    const wallPercent = ((wallCount / totalTiles) * 100).toFixed(1);
    const waterPercent = ((waterCount / totalTiles) * 100).toFixed(1);
    const grassPercent = ((grassCount / totalTiles) * 100).toFixed(1);
    const emptyPercent = ((emptyCount / totalTiles) * 100).toFixed(1);

    console.log(`Final terrain distribution:`);
    console.log(`  WALL: ${wallCount} tiles (${wallPercent}% - target was ${wallDensity}%)`);
    console.log(`  WATER: ${waterCount} tiles (${waterPercent}% - target was ${waterDensity}%)`);
    console.log(`  GRASS: ${grassCount} tiles (${grassPercent}% - target was ${grassDensity}%)`);
    console.log(`  EMPTY: ${emptyCount} tiles (${emptyPercent}%)`);
    console.log('==========================================\n');

    setTiles(newTiles);
  };

  const clearCanvas = () => {
    setTiles(Array(CANVAS_HEIGHT).fill(null).map(() => Array(CANVAS_WIDTH).fill(null)));
  };

  const downloadMap = () => {
    const canvas = document.createElement('canvas');
    canvas.width = CANVAS_WIDTH * TILE_SIZE;
    canvas.height = CANVAS_HEIGHT * TILE_SIZE;
    const ctx = canvas.getContext('2d');
    
    for (let row = 0; row < CANVAS_HEIGHT; row++) {
      for (let col = 0; col < CANVAS_WIDTH; col++) {
        const isEvenRow = row % 2 === 0;
        const isEvenCol = col % 2 === 0;
        const isLightSquare = (isEvenRow && isEvenCol) || (!isEvenRow && !isEvenCol);
        ctx.fillStyle = isLightSquare ? '#FFE4B3' : '#FFDAA3';
        ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        
        if (tiles[row][col]) {
          ctx.fillStyle = tiles[row][col];
          ctx.fillRect(col * TILE_SIZE, row * TILE_SIZE, TILE_SIZE, TILE_SIZE);
        }
      }
    }
    
    canvas.toBlob((blob) => {
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'blink-map.png';
      a.click();
      URL.revokeObjectURL(url);
    });
  };

  const countTiles = () => {
    let wallCount = 0, waterCount = 0, grassCount = 0, emptyCount = 0;
    tiles.forEach(row => {
      row.forEach(tile => {
        if (tile === TERRAIN_TYPES.WALL) wallCount++;
        else if (tile === TERRAIN_TYPES.WATER) waterCount++;
        else if (tile === TERRAIN_TYPES.GRASS) grassCount++;
        else emptyCount++;
      });
    });
    return { wallCount, waterCount, grassCount, emptyCount };
  };

  const tileCounts = countTiles();

  return (
    <div className="min-h-screen relative overflow-hidden" style={{
      background: 'linear-gradient(180deg, #0a1128 0%, #1a2332 50%, #2d1b4e 100%)'
    }}>
      <div className="absolute inset-0 pointer-events-none">
        {[...Array(100)].map((_, i) => (
          <div
            key={`star-${i}`}
            className="absolute bg-white rounded-full"
            style={{
              width: Math.random() * 2 + 1 + 'px',
              height: Math.random() * 2 + 1 + 'px',
              top: Math.random() * 100 + '%',
              left: Math.random() * 100 + '%',
              opacity: Math.random() * 0.5 + 0.3
            }}
          />
        ))}
      </div>

      <div className="relative z-10 bg-black bg-opacity-30 border-b border-purple-500 border-opacity-30 px-4 py-3">
        <div className="flex items-center gap-2">
          <span className="text-3xl">üí´</span>
          <h1 className="text-2xl font-bold text-white">Blink</h1>
        </div>
      </div>

      <div className="relative z-10 flex items-start justify-center gap-4 p-4 max-w-7xl mx-auto">
        <div className="flex flex-col items-center gap-4 flex-1">
          <div 
            ref={canvasRef}
            className="inline-block border-4 border-purple-400 border-opacity-50 shadow-2xl touch-none"
            style={{
              background: '#FFE4B3',
              userSelect: 'none'
            }}
          >
            {tiles.map((row, rowIndex) => (
              <div key={rowIndex} className="flex">
                {row.map((tile, colIndex) => {
                  const isEvenRow = rowIndex % 2 === 0;
                  const isEvenCol = colIndex % 2 === 0;
                  const isLightSquare = (isEvenRow && isEvenCol) || (!isEvenRow && !isEvenCol);
                  
                  return (
                    <div
                      key={`${rowIndex}-${colIndex}`}
                      onMouseDown={() => handleMouseDown(rowIndex, colIndex)}
                      onMouseEnter={() => handleMouseEnter(rowIndex, colIndex)}
                      onTouchStart={(e) => {
                        e.preventDefault();
                        handleMouseDown(rowIndex, colIndex);
                      }}
                      className="cursor-pointer touch-none"
                      style={{
                        width: TILE_SIZE + 'px',
                        height: TILE_SIZE + 'px',
                        backgroundColor: tile || (isLightSquare ? '#FFE4B3' : '#FFDAA3'),
                        border: '0.5px solid rgba(0,0,0,0.05)'
                      }}
                    />
                  );
                })}
              </div>
            ))}
          </div>

          <div className="bg-black bg-opacity-40 border border-cyan-400 border-opacity-50 rounded-lg p-2 w-full max-w-md backdrop-blur-sm">
            <div className="flex items-center justify-center gap-2">
              <div className="flex items-center justify-center px-3 py-2 rounded" style={{ backgroundColor: TERRAIN_TYPES.WALL, minWidth: '60px' }}>
                <span className="text-white text-sm font-bold">{tileCounts.wallCount}</span>
              </div>
              <div className="flex items-center justify-center px-3 py-2 rounded" style={{ backgroundColor: TERRAIN_TYPES.WATER, minWidth: '60px' }}>
                <span className="text-white text-sm font-bold">{tileCounts.waterCount}</span>
              </div>
              <div className="flex items-center justify-center px-3 py-2 rounded" style={{ backgroundColor: TERRAIN_TYPES.GRASS, minWidth: '60px' }}>
                <span className="text-white text-sm font-bold">{tileCounts.grassCount}</span>
              </div>
              <div className="flex items-center justify-center px-3 py-2 rounded bg-orange-200" style={{ minWidth: '60px' }}>
                <span className="text-gray-700 text-sm font-bold">{tileCounts.emptyCount}</span>
              </div>
            </div>
          </div>

          <div className="bg-black bg-opacity-40 border border-purple-400 border-opacity-50 rounded-lg p-4 w-full max-w-md backdrop-blur-sm">
            <h3 className="text-white text-lg font-semibold mb-4 flex items-center gap-2 justify-center">
              <Wand2 size={20} />
              Random Map Generator
            </h3>
            
            <div className="space-y-3">
              <div>
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-white text-sm flex-1">üß± Walls</span>
                  <span className="text-white text-sm">{wallDensity}%</span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={wallDensity}
                  onChange={(e) => setWallDensity(Number(e.target.value))}
                  className="w-full accent-amber-700"
                />
              </div>
              
              <div>
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-white text-sm flex-1">üåä Water</span>
                  <span className="text-white text-sm">{waterDensity}%</span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={waterDensity}
                  onChange={(e) => setWaterDensity(Number(e.target.value))}
                  className="w-full accent-blue-400"
                />
              </div>
              
              <div>
                <div className="flex items-center gap-2 mb-2">
                  <span className="text-white text-sm flex-1">ü•¨ Grass</span>
                  <span className="text-white text-sm">{grassDensity}%</span>
                </div>
                <input
                  type="range"
                  min="0"
                  max="100"
                  value={grassDensity}
                  onChange={(e) => setGrassDensity(Number(e.target.value))}
                  className="w-full accent-green-500"
                />
              </div>

              <button
                onClick={generateRandomMap}
                className="w-full bg-purple-600 hover:bg-purple-700 text-white font-semibold py-3 px-4 rounded-lg flex items-center justify-center gap-2 transition-colors mt-4"
              >
                <Wand2 size={20} />
                Generate Map
              </button>
            </div>
          </div>
        </div>

        <div className="fixed right-0 top-20 z-20 flex items-center">
          <button
            onClick={() => setToolbarOpen(!toolbarOpen)}
            className={`bg-purple-600 hover:bg-purple-700 text-white p-2 rounded-l-lg transition-all ${!toolbarOpen ? 'translate-x-0' : ''}`}
            style={{
              position: toolbarOpen ? 'relative' : 'absolute',
              right: toolbarOpen ? 0 : 0
            }}
          >
            {toolbarOpen ? '‚Üí' : '‚Üê'}
          </button>
          
          <div className={`bg-black bg-opacity-40 border-l border-t border-b border-purple-400 border-opacity-50 rounded-l-lg p-2 backdrop-blur-sm transition-transform duration-300 ${toolbarOpen ? 'translate-x-0' : 'translate-x-full'}`}>
            <div className="flex flex-col gap-2 items-center">
              <button
                onClick={() => setSelectedTool(TERRAIN_TYPES.WALL)}
                className={`w-10 h-10 rounded-lg border-2 transition-all ${
                  selectedTool === TERRAIN_TYPES.WALL 
                    ? 'border-white scale-110 shadow-lg' 
                    : 'border-transparent hover:border-gray-400'
                }`}
                style={{ backgroundColor: TERRAIN_TYPES.WALL }}
                title="Wall"
              />
              <button
                onClick={() => setSelectedTool(TERRAIN_TYPES.WATER)}
                className={`w-10 h-10 rounded-lg border-2 transition-all ${
                  selectedTool === TERRAIN_TYPES.WATER 
                    ? 'border-white scale-110 shadow-lg' 
                    : 'border-transparent hover:border-gray-400'
                }`}
                style={{ backgroundColor: TERRAIN_TYPES.WATER }}
                title="Water"
              />
              <button
                onClick={() => setSelectedTool(TERRAIN_TYPES.GRASS)}
                className={`w-10 h-10 rounded-lg border-2 transition-all ${
                  selectedTool === TERRAIN_TYPES.GRASS 
                    ? 'border-white scale-110 shadow-lg' 
                    : 'border-transparent hover:border-gray-400'
                }`}
                style={{ backgroundColor: TERRAIN_TYPES.GRASS }}
                title="Grass"
              />
              <button
                onClick={() => setSelectedTool(null)}
                className={`w-10 h-10 rounded-lg border-2 bg-gray-700 hover:bg-gray-600 transition-all flex items-center justify-center text-lg ${
                  selectedTool === null 
                    ? 'border-white scale-110 shadow-lg' 
                    : 'border-transparent'
                }`}
                title="Eraser"
              >
                üßπ
              </button>
              
              <div className="w-full border-t border-purple-400 border-opacity-30 my-1" />
              
              <button
                onClick={() => setMirrorVertical(!mirrorVertical)}
                className={`w-10 h-10 rounded-lg transition-all flex items-center justify-center text-lg ${
                  mirrorVertical 
                    ? 'bg-purple-600 text-white' 
                    : 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                }`}
                title="Mirror Vertical"
              >
                ‚ÜîÔ∏è
              </button>
              <button
                onClick={() => setMirrorHorizontal(!mirrorHorizontal)}
                className={`w-10 h-10 rounded-lg transition-all flex items-center justify-center text-lg ${
                  mirrorHorizontal 
                    ? 'bg-purple-600 text-white' 
                    : 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                }`}
                title="Mirror Horizontal"
              >
                ‚ÜïÔ∏è
              </button>
              <button
                onClick={() => setMirrorDiagonal(!mirrorDiagonal)}
                className={`w-10 h-10 rounded-lg transition-all flex items-center justify-center text-lg ${
                  mirrorDiagonal 
                    ? 'bg-purple-600 text-white' 
                    : 'bg-gray-700 hover:bg-gray-600 text-gray-300'
                }`}
                title="Mirror Central"
              >
                üîÑ
              </button>
              
              <div className="w-full border-t border-purple-400 border-opacity-30 my-1" />
              
              <button
                onClick={clearCanvas}
                className="w-10 h-10 rounded-lg bg-red-600 hover:bg-red-700 flex items-center justify-center transition-colors"
                title="Clear All"
              >
                <Trash2 size={18} className="text-white" />
              </button>
              <button
                onClick={downloadMap}
                className="w-10 h-10 rounded-lg bg-green-600 hover:bg-green-700 flex items-center justify-center transition-colors"
                title="Download PNG"
              >
                <Download size={18} className="text-white" />
              </button>
            </div>
          </div>
        </div>
      </div>
    </div>
  );
};

export default MapGenerator;
